// Copyright (c) 2024 The Jaeger Authors.
// SPDX-License-Identifier: Apache-2.0

package adjuster

import (
	"fmt"
	"hash/fnv"
	"unsafe"

	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/ptrace"

	"github.com/jaegertracing/jaeger/internal/jptrace"
	"github.com/jaegertracing/jaeger/model"
)

var _ Adjuster = (*SpanHashDeduper)(nil)

// DeduplicateSpans creates an adjuster that deduplicates spans by removing all but one span
// with the same hash code. This is particularly useful for scenarios where spans
// may be duplicated during archival, such as with ElasticSearch archival.
//
// The hash code is generated by serializing the span into protobuf bytes and applying
// the FNV hashing algorithm to the serialized data.
//
// To ensure consistent hash codes, this adjuster should be executed after
// SortAttributesAndEvents, which normalizes the order of collections within the span.
func DeduplicateSpans() *SpanHashDeduper {
	return &SpanHashDeduper{
		marshaler: &ptrace.ProtoMarshaler{},
	}
}

type SpanHashDeduper struct {
	marshaler ptrace.Marshaler
}

func (s *SpanHashDeduper) Adjust(traces ptrace.Traces) {
	spansByHash := make(map[int64]ptrace.Span)
	resourceSpans := traces.ResourceSpans()
	for i := 0; i < resourceSpans.Len(); i++ {
		rs := resourceSpans.At(i)
		scopeSpans := rs.ScopeSpans()
		hashTrace := ptrace.NewTraces()
		hashResourceSpan := hashTrace.ResourceSpans().AppendEmpty()
		hashScopeSpan := hashResourceSpan.ScopeSpans().AppendEmpty()
		hashSpan := hashScopeSpan.Spans().AppendEmpty()
		rs.Resource().Attributes().CopyTo(hashResourceSpan.Resource().Attributes())
		for j := 0; j < scopeSpans.Len(); j++ {
			ss := scopeSpans.At(j)
			spans := ss.Spans()
			ss.Scope().Attributes().CopyTo(hashScopeSpan.Scope().Attributes())
			dedupedSpans := ptrace.NewSpanSlice()
			for k := 0; k < spans.Len(); k++ {
				span := spans.At(k)
				span.CopyTo(hashSpan)

				var spanHash int64
				if hashAttr, ok := span.Attributes().Get(model.SpanHashKey); ok {
					if hashAttr.Type() != pcommon.ValueTypeInt {
						jptrace.AddWarnings(span, "span hash attribute is not an integer type")
						span.CopyTo(dedupedSpans.AppendEmpty())
						continue
					}
					spanHash = hashAttr.Int()
				} else {
					h, err := s.computeHashCode(hashTrace)
					if err != nil {
						jptrace.AddWarnings(span, fmt.Sprintf("failed to compute hash code: %v", err))
						span.CopyTo(dedupedSpans.AppendEmpty())
						continue
					}
					spanHash = uint64ToInt64Bits(h)
				}

				if _, ok := spansByHash[spanHash]; !ok {
					spansByHash[spanHash] = span
					span.CopyTo(dedupedSpans.AppendEmpty())
				}
			}
			dedupedSpans.CopyTo(spans)
		}
	}
}

func (s *SpanHashDeduper) computeHashCode(
	hashTrace ptrace.Traces,
) (uint64, error) {
	b, err := s.marshaler.MarshalTraces(hashTrace)
	if err != nil {
		return 0, err
	}
	hasher := fnv.New64a()
	hasher.Write(b) // the writer in the Hash interface never returns an error
	return hasher.Sum64(), nil
}

func uint64ToInt64Bits(value uint64) int64 {
	return *(*int64)(unsafe.Pointer(&value))
}
